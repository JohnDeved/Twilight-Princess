name: Port Test (PC Headless)

on:
  push:
    branches:
      - port
    paths:
      - 'src/**'
      - 'include/**'
      - 'CMakeLists.txt'
      - '.github/workflows/port-test.yml'
      - 'tools/**'
      - 'milestone-baseline.json'
      - 'tests/**'
  pull_request:
    paths:
      - 'src/**'
      - 'include/**'
      - 'CMakeLists.txt'
      - '.github/workflows/port-test.yml'
      - 'tools/**'
      - 'milestone-baseline.json'
      - 'tests/**'

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install dependencies
        run: |
          sudo apt-get update -q
          sudo apt-get install -y ccache ninja-build libgl-dev libx11-dev libwayland-dev libxrandr-dev libxinerama-dev libxcursor-dev libxi-dev libxkbcommon-dev libasound2-dev libpulse-dev libdbus-1-dev xvfb

      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ~/.cache/ccache
          key: ccache-${{ runner.os }}-${{ hashFiles('CMakeLists.txt') }}
          restore-keys: |
            ccache-${{ runner.os }}-

      - name: Cache FetchContent deps
        uses: actions/cache@v4
        with:
          path: build/_deps
          key: deps-${{ runner.os }}-${{ hashFiles('CMakeLists.txt') }}
          restore-keys: |
            deps-${{ runner.os }}-

      - name: Configure ccache
        run: |
          ccache --set-config=max_size=500M
          ccache --set-config=compression=true
          ccache -z

      - name: Set up game data
        if: env.ROMS_TOKEN != ''
        env:
          ROMS_TOKEN: ${{ secrets.ROMS_TOKEN }}
        run: |
          python3 tools/setup_game_data.py \
            --data-dir data \
            --rom-dir orig/GZ2E01 \
            --extract-dir build/extract/GZ2E01 \
            --tools-dir build/tools

      - name: Cache disc image
        if: env.ROMS_TOKEN != ''
        uses: actions/cache@v4
        with:
          path: orig/GZ2E01/GZ2E01.rvz
          key: rom-GZ2E01-v1

      - name: Build PC port
        env:
          ROMS_TOKEN: ${{ secrets.ROMS_TOKEN }}
        run: |
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DTP_VERSION=PC
          ninja -C build tp-pc

      - name: ccache stats
        if: always()
        run: ccache -s

      - name: Run headless test
        if: success()
        env:
          TP_HEADLESS: "1"
          TP_TEST_FRAMES: "2000"
          TP_SCREENSHOT: "logo_render.bmp"
          TP_VERIFY: "1"
          TP_VERIFY_DIR: "verify_output"
          TP_VERIFY_CAPTURE_FRAMES: "1,10,30,60,120,300,600,1200,1800"
        run: |
          set -o pipefail
          mkdir -p verify_output
          # Start Xvfb for software OpenGL rendering (no GPU needed).
          # bgfx renders via Mesa llvmpipe, captures every frame.
          Xvfb :99 -screen 0 640x480x24 &
          XVFB_PID=$!
          export DISPLAY=:99
          sleep 1
          timeout 120s build/tp-pc 2>&1 | tee milestones.log || true
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          kill $XVFB_PID 2>/dev/null || true
          if [ -f logo_render.bmp ]; then
            echo "Screenshot captured: $(ls -la logo_render.bmp)"
          fi

      - name: Parse milestones
        if: always()
        run: |
          # || true: Always produce the report JSON for the PR comment step.
          # Failures are surfaced in the regression check, not here.
          python3 tools/parse_milestones.py milestones.log \
            --output milestone-summary.json \
            --min-milestone 5 || true

      - name: Verify port subsystems
        if: always()
        run: |
          # || true: Always produce the report JSON for the PR comment step.
          # Rendering issues are surfaced in the PR comment, not as build failures.
          python3 tools/verify_port.py milestones.log \
            --output verify-report.json \
            --verify-dir verify_output \
            --golden-dir tests/golden \
            --render-baseline tests/render-baseline.json \
            --check-all || true

      - name: Check milestone regression
        id: regression
        if: always()
        run: |
          python3 tools/check_milestone_regression.py milestone-summary.json \
            --baseline milestone-baseline.json \
            --output regression-report.json \
            --auto-update || true

          # Extract key fields for the PR comment step
          if [ -f regression-report.json ]; then
            echo "status=$(python3 -c "import json; print(json.load(open('regression-report.json'))['status'])")" >> $GITHUB_OUTPUT
            echo "current=$(python3 -c "import json; print(json.load(open('regression-report.json'))['current_milestone_count'])")" >> $GITHUB_OUTPUT
            echo "baseline=$(python3 -c "import json; print(json.load(open('regression-report.json'))['baseline_milestone_count'])")" >> $GITHUB_OUTPUT
            echo "delta=$(python3 -c "import json; print(json.load(open('regression-report.json'))['delta'])")" >> $GITHUB_OUTPUT
          fi

      - name: Commit updated baseline
        if: always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        run: |
          if [ ! -f milestone-baseline.json ]; then
            echo "No baseline file found, skipping"
            exit 0
          fi
          if git diff --quiet milestone-baseline.json; then
            echo "Baseline unchanged, nothing to commit"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add milestone-baseline.json
            COMMIT_MSG="ci: auto-update milestone baseline"
            if [ -f regression-report.json ]; then
              COMMIT_MSG="ci: auto-update milestone baseline ($(python3 -c "import json; r=json.load(open('regression-report.json')); print(f\"{r['baseline_milestone_count']} ‚Üí {r['current_milestone_count']}\")" 2>/dev/null || echo "improved"))"
            fi
            git commit -m "$COMMIT_MSG"
            git push origin HEAD:${{ github.head_ref }}
            echo "‚úÖ Baseline committed and pushed"
          fi

      - name: Convert screenshots and generate video
        if: always()
        run: |
          python3 tools/convert_frames.py verify_output \
            --png-dir verify_png \
            --video verify_output/render_progress.mp4 \
            --fps 4 || true

      - name: Post PR comment with results
        if: always() && github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Load milestone summary
            let summary = {};
            try {
              summary = JSON.parse(fs.readFileSync('milestone-summary.json', 'utf8'));
            } catch (e) {
              summary = { milestones_reached_count: 0, milestones_reached: [] };
            }

            // Load regression report
            let regression = {};
            try {
              regression = JSON.parse(fs.readFileSync('regression-report.json', 'utf8'));
            } catch (e) {
              regression = { status: 'unknown', current_milestone: -1, baseline_milestone: -1 };
            }

            // Load verification report
            let verify = { checks: {} };
            try {
              verify = JSON.parse(fs.readFileSync('verify-report.json', 'utf8'));
            } catch (e) {
              // no verification data
            }

            // Upload frame PNGs to a release for embedding in the comment
            const pngDir = 'verify_png';
            const path = require('path');
            const imageUrls = {};
            let capturedPngs = [];

            if (fs.existsSync(pngDir)) {
              capturedPngs = fs.readdirSync(pngDir).filter(f => f.endsWith('.png')).sort();
            }
            const hasVideo = fs.existsSync('verify_output/render_progress.mp4');

            if (capturedPngs.length > 0 || hasVideo) {
              // Find or create a prerelease for CI render assets
              const tag = 'ci-renders';
              let release;
              try {
                const existing = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: tag,
                });
                release = existing.data;
              } catch (e) {
                try {
                  const created = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tag,
                    name: 'CI Render Screenshots',
                    body: 'Automatically updated by port-test CI. Contains render frame captures.',
                    prerelease: true,
                  });
                  release = created.data;
                } catch (e2) {
                  console.log(`Could not create release: ${e2.message}`);
                }
              }

              if (release) {
                // Delete old assets
                for (const asset of release.assets || []) {
                  try {
                    await github.rest.repos.deleteReleaseAsset({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      asset_id: asset.id,
                    });
                  } catch (e) {}
                }

                // Upload PNGs
                for (const png of capturedPngs) {
                  const filePath = path.join(pngDir, png);
                  const data = fs.readFileSync(filePath);
                  try {
                    const uploaded = await github.rest.repos.uploadReleaseAsset({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      release_id: release.id,
                      name: png,
                      data: data,
                      headers: {
                        'content-type': 'application/octet-stream',
                        'content-length': data.length,
                      },
                    });
                    imageUrls[png] = uploaded.data.browser_download_url;
                  } catch (e) {
                    console.log(`Failed to upload ${png}: ${e.message}`);
                  }
                }

                // Upload video
                if (hasVideo) {
                  const videoData = fs.readFileSync('verify_output/render_progress.mp4');
                  try {
                    const uploaded = await github.rest.repos.uploadReleaseAsset({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      release_id: release.id,
                      name: 'render_progress.mp4',
                      data: videoData,
                      headers: {
                        'content-type': 'application/octet-stream',
                        'content-length': videoData.length,
                      },
                    });
                    imageUrls['video'] = uploaded.data.browser_download_url;
                  } catch (e) {
                    console.log(`Failed to upload video: ${e.message}`);
                  }
                }
              }
            }

            // Artifacts URL for this run
            const artifactsUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            // Status emoji
            const statusEmoji = {
              'improved': 'üéâ',
              'same': '‚úÖ',
              'regressed': 'üö®',
              'unknown': '‚ùì'
            };

            const emoji = statusEmoji[regression.status] || '‚ùì';
            const milestoneCount = summary.milestones_reached_count ?? 0;
            const totalMilestones = 16;

            // Build the comment body
            let body = `## ${emoji} Port Test Results\n\n`;
            body += `| Metric | Value |\n|---|---|\n`;
            body += `| **Milestones Reached** | ${milestoneCount} / ${totalMilestones} |\n`;
            body += `| **Baseline** | ${regression.baseline_milestone_count ?? 'N/A'} |\n`;
            body += `| **Status** | ${(regression.status || 'unknown').toUpperCase()} |\n`;
            body += `| **Delta** | ${regression.delta >= 0 ? '+' : ''}${regression.delta ?? 0} |\n`;
            body += `| **Integrity** | ${summary.integrity?.valid ? '‚úÖ VALID' : 'üö´ FAILED'} |\n`;

            // Integrity check failures
            if (summary.integrity && !summary.integrity.valid) {
              body += `\n### üö´ Integrity Check Failed\n`;
              body += `> The following milestones were disqualified and excluded from the count:\n\n`;
              for (const issue of (summary.integrity.issues || [])) {
                body += `- ‚ùå ${issue}\n`;
              }
              const disqualified = summary.integrity.disqualified_milestones || [];
              if (disqualified.length > 0) {
                body += `\n**Disqualified milestones:** ${disqualified.join(', ')}\n`;
              }
              body += `\n> Fix the underlying issues ‚Äî disqualified milestones do not count.\n`;
            }

            // Milestones reached
            if (summary.milestones_reached && summary.milestones_reached.length > 0) {
              body += `\n### Milestones Reached\n`;
              body += summary.milestones_reached.map(m => `- ‚úÖ ${m}`).join('\n') + '\n';
            }

            // Crash info
            if (summary.crash) {
              body += `\n### ‚ö†Ô∏è Crash Detected\n`;
              body += `Signal: ${summary.crash.signal || 'unknown'}\n`;
            }

            // Top stubs
            if (summary.stubs_hit && summary.stubs_hit.length > 0) {
              body += `\n### üìä Top Unimplemented Stubs\n`;
              body += `| Stub | Hits |\n|---|---|\n`;
              for (const s of summary.stubs_hit.slice(0, 10)) {
                body += `| \`${s.stub}\` | ${s.hits} |\n`;
              }
            }

            // Frame validation
            if (summary.frame_validation) {
              const fv = summary.frame_validation;
              body += `\n### üñºÔ∏è Frame Validation\n`;
              body += `| Metric | Value |\n|---|---|\n`;
              body += `| Stub count | ${fv.stub_count} |\n`;
              body += `| Draw calls | ${fv.draw_calls} |\n`;
              body += `| Valid verts | ${fv.valid_verts} |\n`;
              body += `| Valid frame | ${fv.valid ? '‚úÖ' : '‚ùå'} |\n`;
            }

            // Timing
            if (summary.timing && Object.keys(summary.timing).length > 0) {
              body += `\n### ‚è±Ô∏è Timing\n`;
              body += `| Milestone | Time (ms) |\n|---|---|\n`;
              for (const [name, ms] of Object.entries(summary.timing)) {
                body += `| ${name} | ${ms} |\n`;
              }
            }

            // Subsystem verification results
            if (verify.checks && Object.keys(verify.checks).length > 0) {
              body += `\n### üîç Subsystem Verification\n`;
              body += `| Subsystem | Status | Details |\n|---|---|---|\n`;
              for (const [name, check] of Object.entries(verify.checks)) {
                const checkEmoji = check.passed ? '‚úÖ' : '‚ùå';
                let detail = '';
                if (check.details) {
                  if (name === 'rendering') {
                    const fw = check.details.frames_with_draws ?? 0;
                    const fn = check.details.frames_nonblack ?? 0;
                    const rh = check.details.render_health_pct ?? 0;
                    detail = `${fw} frames with draws, ${fn} non-black, ${rh}% health`;
                  } else if (name === 'input') {
                    detail = check.details.note || `${check.details.input_events ?? 0} events, ${check.details.input_responses ?? 0} responses`;
                  } else if (name === 'audio') {
                    detail = check.details.note || `${check.details.audio_frames_active ?? 0} active, ${check.details.audio_frames_nonsilent ?? 0} non-silent`;
                  }
                }
                if (check.issues && check.issues.length > 0) {
                  detail += (detail ? ' ¬∑ ' : '') + check.issues.join('; ');
                }
                body += `| ${name} | ${checkEmoji} | ${detail} |\n`;
              }

              // Render pipeline health breakdown
              const pipelineData = verify.checks?.rendering?.details?.pipeline;
              if (pipelineData && pipelineData.stages) {
                body += `\n### üîß Render Pipeline Health\n`;
                body += `| Stage | Status | Details |\n|---|---|---|\n`;
                const stageNames = {
                  geometry: 'üìê Geometry',
                  textures: 'üñºÔ∏è Textures',
                  shaders: 'üé® Shaders',
                  depth: 'üìè Depth Test',
                  blend: 'üîÆ Blending',
                  primitives: 'üî∫ Primitives',
                };
                for (const [stageName, stage] of Object.entries(pipelineData.stages)) {
                  const stageEmoji = stage.ok ? '‚úÖ' : '‚ùå';
                  const displayName = stageNames[stageName] || stageName;
                  const details = Object.entries(stage)
                    .filter(([k]) => k !== 'ok')
                    .map(([k, v]) => `${k}=${Array.isArray(v) ? v.join(',') : v}`)
                    .join(', ');
                  body += `| ${displayName} | ${stageEmoji} | ${details} |\n`;
                }
                body += `| **Visual Complexity** | | **${pipelineData.visual_complexity ?? 0}/100** |\n`;
              }

              // Frame progression
              const progressionData = verify.checks?.rendering?.details?.progression;
              if (progressionData) {
                const hc = progressionData.hash_changes ?? 0;
                const dh = progressionData.distinct_hashes ?? 0;
                body += `\nüìà **Frame progression:** ${hc} hash changes, ${dh} distinct hashes\n`;
              }
            }

            // Render screenshots ‚Äî embed uploaded images
            const renderCheck = verify.checks?.rendering;
            const fbAnalyses = renderCheck?.details?.captured_frames;
            const frameHashes = renderCheck?.details?.frame_hashes;
            const sortedPngs = Object.keys(imageUrls).filter(k => k !== 'video').sort();

            if (sortedPngs.length > 0) {
              body += `\n### üì∏ Render Screenshots\n`;
              // Show key frames inline (first, middle, last ‚Äî up to 6)
              const keyFrames = sortedPngs.length <= 6
                ? sortedPngs
                : [sortedPngs[0], sortedPngs[Math.floor(sortedPngs.length / 3)], sortedPngs[Math.floor(2 * sortedPngs.length / 3)], sortedPngs[sortedPngs.length - 1]];
              for (const png of keyFrames) {
                const frameNum = png.replace('frame_', '').replace('.png', '');
                body += `\n**Frame ${frameNum}**\n\n`;
                body += `![Frame ${frameNum}](${imageUrls[png]})\n`;
              }
              // Collapsible section with all frames if many
              if (sortedPngs.length > 6) {
                body += `\n<details><summary>All ${sortedPngs.length} captured frames</summary>\n\n`;
                for (const png of sortedPngs) {
                  if (!keyFrames.includes(png)) {
                    const frameNum = png.replace('frame_', '').replace('.png', '');
                    body += `**Frame ${frameNum}** ¬∑ ![Frame ${frameNum}](${imageUrls[png]})\n\n`;
                  }
                }
                body += `</details>\n`;
              }
            } else if (fbAnalyses && fbAnalyses.length > 0) {
              // Fallback: show text-only frame analysis if no images uploaded
              body += `\n### üì∏ Captured Frames\n`;
              body += `| Frame | Non-Black | Avg Color | Hash |\n|---|---|---|---|\n`;
              for (const fa of fbAnalyses) {
                const frameNum = fa.file?.replace('frame_', '').replace('.bmp', '') || '?';
                const nb = fa.pct_nonblack ?? 0;
                const ac = fa.avg_color || [0,0,0];
                const hash = frameHashes?.[frameNum] || '‚Äî';
                body += `| ${frameNum} | ${nb}% | \`${ac.join(',')}\` | \`${hash}\` |\n`;
              }
            }

            // Video link
            if (imageUrls['video']) {
              body += `\n### üé¨ Render Progress Video\n`;
              body += `[‚ñ∂Ô∏è Download render_progress.mp4](${imageUrls['video']})\n`;
            }

            // Golden image comparisons
            const goldenComps = renderCheck?.details?.golden_comparisons;
            if (goldenComps && goldenComps.length > 0) {
              const hasAnyGolden = goldenComps.some(c => c.has_golden);
              if (hasAnyGolden) {
                body += `\n### üñºÔ∏è Golden Image Comparison\n`;
                body += `| Frame | RMSE | % Different | Status |\n|---|---|---|---|\n`;
                for (const cmp of goldenComps) {
                  if (cmp.has_golden) {
                    const status = cmp.identical ? '‚úÖ Identical' : (cmp.rmse <= 5.0 ? '‚úÖ Within tolerance' : '‚ùå REGRESSION');
                    body += `| ${cmp.frame} | ${cmp.rmse ?? 0} | ${cmp.pct_different ?? 0}% | ${status} |\n`;
                  }
                }
              }
            }

            // Artifacts download link
            body += `\n### üì¶ Artifacts\n`;
            body += `[Download full test results](${artifactsUrl})\n`;

            body += `\n---\n`;
            body += `<sub>ü§ñ Generated by port-test CI ¬∑ `;
            body += `Commit: ${context.sha.substring(0, 7)}</sub>\n`;

            // Find and update existing comment, or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              (c.body.includes('Port Test Results') && c.body.includes('Milestones Reached'))
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body,
              });
            }

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: port-test-results
          path: |
            milestones.log
            milestone-summary.json
            regression-report.json
            verify-report.json
            verify_output/
            verify_png/
            logo_render.bmp
